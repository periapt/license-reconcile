#!/usr/bin/perl 
use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;
use File::Slurp;
use Readonly;
use Debian::LicenseReconcile::Errors;
use Debian::LicenseReconcile::FormatSpec;
use Debian::LicenseReconcile::CopyrightTarget;
use Debian::LicenseReconcile::LicenseCheck;
use Debian::LicenseReconcile;
use Parse::DebianChangelog;
use UNIVERSAL::require;
use Config::Any;

my $man = 0;
my $help = 0;
my $quiet = 0;
my $display_mapping = 0;
my $directory = ".";
my @filters = qw(Rules Std Shebang ChangeLog Default);
my @filters_override = ();
my $config_file = 'debian/license-reconcile.yml';
my $changelog_file = 'debian/changelog';

my $copyright = 'debian/copyright';

my $format_spec = 1;

GetOptions(
    'help|?' => \$help,
    man => \$man,
    'copyright=s' => \$copyright,
    'format-spec!' => \$format_spec,
    'quiet!' => \$quiet,
    'display-mapping!' => \$display_mapping,
    'directory=s' => \$directory,
    'config-file=s' => \$config_file,
    'changelog-file=s' => \$changelog_file,
    'filters=s@' => sub {
        shift; # name of option
        my $value = shift;
        if (not grep {$value eq $_} @filters_override) {
            push @filters_override, $value;
        }
    },
) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;

if (@filters_override) {
    @filters = @filters_override;
}

Readonly my $COPYRIGHT_TEXT => scalar read_file($copyright);

Readonly my $CHANGELOG => Parse::DebianChangelog->init({infile=>$changelog_file});

if ($format_spec) {
        Debian::LicenseReconcile::FormatSpec->check($COPYRIGHT_TEXT);
}

Readonly my $CONFIG => Config::Any->load_files({
    files=>[$config_file],
    use_ext=>1,
    flatten_to_hash=>1,
})->{$config_file};

Readonly my $LICENSECHECK => Debian::LicenseReconcile::LicenseCheck->new(
    $directory,
    $CONFIG->{LicenseCheck}
);

my $copyright_target = Debian::LicenseReconcile::CopyrightTarget->new;
if ($copyright_target->parse($COPYRIGHT_TEXT)) {

    my $file_mapping = $copyright_target->map_directory($directory);

    if ($display_mapping) {
        foreach my $file (keys %$file_mapping) {
            print "$file: $file_mapping->{$file}->{pattern}\n";
        }
    }

    my $reconcile = Debian::LicenseReconcile->new;
    my %file_checked = ();
    foreach my $filter_name (@filters) {
        my $class = "Debian::LicenseReconcile::Filter::$filter_name";
        $class->require;
        my @files_remaining = grep {not exists $file_checked{$_}} keys %$file_mapping;
        my $test = $class->new(
            directory=>$directory,
            files_remaining=>\@files_remaining,
            config=>$CONFIG->{$filter_name},
            changelog=>$CHANGELOG,
            licensecheck=>$LICENSECHECK,
        );
        foreach my $titbit ($test->get_info) {
            next if $file_checked{$titbit->{file}};
            $file_checked{$titbit->{file}} = 1;
            if (exists $file_mapping->{$titbit->{file}}) {
                $reconcile->check($titbit, $file_mapping->{$titbit->{file}});
            }
            else {
                Debian::LicenseReconcile::Errors->push(
                    test => 'File mismatch',
                    msg => "Filter $filter_name found $titbit->{file} which was not in the file mapping. This probably implies a bug in the filter.",
                );
            }
        }
    }

}

if (not $quiet) {
    foreach my $error (Debian::LicenseReconcile::Errors->list) {
        warn "$error->{test}: $error->{msg}";
    }
}

exit(Debian::LicenseReconcile::Errors->how_many);

=head1 NAME

license-reconcile - reconcile debian/copyright against source

=head1 SYNOPSIS

B<license-reconcile> B<--help>|B<--man>

B<license-reconcile> [B<--copyright=>I<file>] [B<--no-format-spec>] [B<--quiet>] [B<--display-mapping>] [B<--directory=>I<directory>] [B<--filters=>I<module1 module2 ...>] [B<--config-file=>I<file>] [B<--changelog-file=>I<file>]

=head1 DESCRIPTION

B<license-reconcile> attempts to match license and copyright information
in a directory with the information available in C<debian/copyright>.
It gets most of its data from C<licensecheck> so should produce something
worth looking at out of the box.
However for a given package it can be configured to succeed in a known good
state, so that if on subsequent upstream updates it fails, it points out
what needs looking at.
By default the tests run are as follows:

=over

=item - Does the copyright file have an approved format specification as its
first line?

=item - Can the copyright file be parsed?

=item - Does every file in the source match at least one clause in the copyright
file?

=item - Can every file, license and copyright datum extracted from the source be
contained in the corresponding matching paragraph from the copyright file?
The data for this comparison comes from a number filter objects. See L</Filters>
for more information.

=back

=head1 OPTIONS

=head2 B<--copyright=>I<file>

Specify an alternative copyright file. Defaults to C<debian/copyright>.

=head2 B<--no-format-spec>

Don't check the first line of the copyright file against permitted format
specifications.

=head2 B<--quiet>

Don't give any explanations, simply a success or a fail via the exit status.

=head2 B<--display-mapping>

Display mapping from the directory onto the copyright clauses.

=head2 B<--directory=>I<directory>

The directory whose copyright and licenses will be verified. This defaults to ".".

=head2 B<--filters=>I<module1 module2 ....>

A sequence of filters which will inspect the source package and return
license and copyright information. Each module name must sit below the
L<Debian::LicenseReconcile::Filter> and inherit from it. The default value 
is "Rules Std Shebang ChangeLog Default".

=head2 B<--config-file=>I<file>

A file used to provide filter specific configuration data. The file is read
by L<Config::Any> and the relevant section is passed to each filter constructor
via the C<config> parameter.

=head2 <--changelog-file=>I<file>

The Debian changelog file which defaults to C<debian/changelog>. The Rules filter
uses this to get the current version and the ChangeLog filter gets its data
from it.

=head1 Filters

By default the filters are processed in the order below. Once a file has been
returned by a filter, subsequent filters will ignore it.

=over

=item - L<Rules|Debian::LicenseReconcile::Filter::Rules>

=item - L<Std|Debian::LicenseReconcile::Filter::Std>

=item - L<Shebang|Debian::LicenseReconcile::Filter::Shebang>

=item - L<ChangeLog|Debian::LicenseReconcile::Filter::ChangeLog>

=item - L<Default|Debian::LicenseReconcile::Filter::Default>

=back

Each filter constructor will be passed the following parameters:

=over

=item - directory - the directory from which to find license and copyright data.

=item - files_remaining - an array ref of files which have not been analyzed.

=item - config - a data structure representing the portion of the config file
relevant to this filter.

=item - changelog - a L<Parse::DebianChangelog> object.

=item - licensecheck - a L<Debian::LicenseReconcile::LicenseCheck> object.

=back

=head1 LIMITATIONS

Currently I am ignoring the copyright data and concentrating on the license data.

Also the DEP-5 specification is subtly different from the file glob specification.
Since the L<File::FnMatch> module is the only practical implementation there
is little that can be done. The consequence is that attempting to specify that a
file name should contain '[' or ']' in C<debian/copyright> is unlikely to work
correctly.

=head1 AUTHOR

Nicholas Bamber, C<< <nicholas at periapt.co.uk> >>

=head1 LICENSE AND COPYRIGHT

Copyright 2012 Nicholas Bamber.

This program is free software; you can redistribute it and/or modify it
under the terms of either: the GNU General Public License as published
by the Free Software Foundation; or the Artistic License.

See http://dev.perl.org/licenses/ for more information.

=cut
