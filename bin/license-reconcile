#!/usr/bin/perl 
use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;
use File::Slurp;
use Readonly;
use Debian::LicenseReconcile::Errors;
use Debian::LicenseReconcile::FormatSpec;
use Debian::LicenseReconcile::CopyrightTarget;
use Debian::LicenseReconcile;
use UNIVERSAL::require;

my $man = 0;
my $help = 0;
my $quiet = 0;
my $display_mapping = 0;
my $directory = ".";
my @filters = qw(Std);

my $copyright = 'debian/copyright';

my $format_spec = 1;

GetOptions(
    'help|?' => \$help,
    man => \$man,
    'copyright=s' => \$copyright,
    'format-spec!' => \$format_spec,
    'quiet!' => \$quiet,
    'display-mapping!' => \$display_mapping,
    'directory=s' => \$directory,
) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;

Readonly my $COPYRIGHT_TEXT => scalar read_file($copyright);

if ($format_spec) {
        Debian::LicenseReconcile::FormatSpec->check($COPYRIGHT_TEXT);
}

my $copyright_target = Debian::LicenseReconcile::CopyrightTarget->new;
if ($copyright_target->parse($COPYRIGHT_TEXT)) {

    my $file_mapping = $copyright_target->map_directory($directory);

    if ($display_mapping) {
        foreach my $file (keys %$file_mapping) {
            print "$file: $file_mapping->{$file}->{pattern}\n";
        }
    }

    my $reconcile = Debian::LicenseReconcile->new;
    my %file_checked = ();
    foreach my $filter_name (@filters) {
        my $class = "Debian::LicenseReconcile::Filter::$filter_name";
        $class->require;
        my $test = $class->new(
            directory=>$directory,
        );
        foreach my $titbit ($test->get_info) {
            next if $file_checked{$titbit->{file}};
            $file_checked{$titbit->{file}} = 1;
            if (exists $file_mapping->{$titbit->{file}}) {
                $reconcile->check($titbit, $file_mapping->{$titbit->{file}});
            }
            else {
                Debian::LicenseReconcile::Errors->push(
                    test => 'File mismatch',
                    msg => "Filter $filter_name found $titbit->{file} which was not in the file mapping. This probably implies a bug in the filter.",
                );
            }
        }
    }

}

if (not $quiet) {
    foreach my $error (Debian::LicenseReconcile::Errors->list) {
        warn "$error->{test}: $error->{msg}";
    }
}

exit(Debian::LicenseReconcile::Errors->how_many);

=head1 NAME

license-reconcile - reconcile debian/copyright against source

=head1 SYNOPSIS

B<license-reconcile> B<--help>|B<--man>

B<license-reconcile> [B<--copyright=>I<file>] [B<--no-format-spec>] [B<--quiet>] [B<--display-mapping>] [B<--directory=>I<directory>] [B<--default-license=>I<spec>]

=head1 DESCRIPTION

B<license-reconcile> attempts to match license and copyright information
in a directory with the information available in C<debian/copyright>.
By default the tests run are as follows:

=over

=item - Does the copyright file have an approved format specification as its
first line?

=item - Can the copyright file be parsed?

=item - Can every file, license and copyright datum extracted from the source be
contained in the corresponding matching paragraph from the copyright file?

=back

=head1 OPTIONS

=head2 B<--copyright=>I<file>

Specify an alternative copyright file. Defaults to C<debian/copyright>.

=head2 B<--no-format-spec>

Don't check the first line of the copyright file against permitted format
specifications.

=head2 B<--quiet>

Don't give any explanantions, simply a success or a fail via the exit status.

=head2 B<--display-mapping>

Display mapping from the directory onto the copyright clauses.

=head2 B<--directory=>I<directory>

The directory whose copyright and licenses will be verified.

